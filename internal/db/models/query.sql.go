// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package models

import (
	"context"

	"github.com/google/uuid"
)

const createSequence = `-- name: CreateSequence :one
INSERT INTO sequences (
  name, open_tracking_enabled, click_tracking_enabled
) VALUES ($1, $2, $3) RETURNING id
`

type CreateSequenceParams struct {
	Name                 string `db:"name"`
	OpenTrackingEnabled  bool   `db:"open_tracking_enabled"`
	ClickTrackingEnabled bool   `db:"click_tracking_enabled"`
}

func (q *Queries) CreateSequence(ctx context.Context, arg *CreateSequenceParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createSequence, arg.Name, arg.OpenTrackingEnabled, arg.ClickTrackingEnabled)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createSequenceStep = `-- name: CreateSequenceStep :one
INSERT INTO sequence_steps (
  sequence_id, days_after_previous_step, email_subject, email_content, ordering
) VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type CreateSequenceStepParams struct {
	SequenceID            uuid.UUID `db:"sequence_id"`
	DaysAfterPreviousStep int32     `db:"days_after_previous_step"`
	EmailSubject          string    `db:"email_subject"`
	EmailContent          string    `db:"email_content"`
	Ordering              float32   `db:"ordering"`
}

func (q *Queries) CreateSequenceStep(ctx context.Context, arg *CreateSequenceStepParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createSequenceStep,
		arg.SequenceID,
		arg.DaysAfterPreviousStep,
		arg.EmailSubject,
		arg.EmailContent,
		arg.Ordering,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteSequenceStep = `-- name: DeleteSequenceStep :exec
DELETE FROM sequence_steps WHERE id = $1
`

func (q *Queries) DeleteSequenceStep(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSequenceStep, id)
	return err
}

const getSequenceByID = `-- name: GetSequenceByID :one
SELECT id, name, open_tracking_enabled, click_tracking_enabled, created_at, updated_at FROM sequences WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSequenceByID(ctx context.Context, id uuid.UUID) (*Sequence, error) {
	row := q.db.QueryRow(ctx, getSequenceByID, id)
	var i Sequence
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OpenTrackingEnabled,
		&i.ClickTrackingEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSequenceStepByID = `-- name: GetSequenceStepByID :one
SELECT id, sequence_id, days_after_previous_step, email_subject, email_content, ordering, created_at, updated_at FROM sequence_steps WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSequenceStepByID(ctx context.Context, id uuid.UUID) (*SequenceStep, error) {
	row := q.db.QueryRow(ctx, getSequenceStepByID, id)
	var i SequenceStep
	err := row.Scan(
		&i.ID,
		&i.SequenceID,
		&i.DaysAfterPreviousStep,
		&i.EmailSubject,
		&i.EmailContent,
		&i.Ordering,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSequenceStepsBySequenceID = `-- name: GetSequenceStepsBySequenceID :many
SELECT id, sequence_id, days_after_previous_step, email_subject, email_content, ordering, created_at, updated_at FROM sequence_steps WHERE sequence_id = $1 ORDER BY ordering ASC
`

func (q *Queries) GetSequenceStepsBySequenceID(ctx context.Context, sequenceID uuid.UUID) ([]*SequenceStep, error) {
	rows, err := q.db.Query(ctx, getSequenceStepsBySequenceID, sequenceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SequenceStep
	for rows.Next() {
		var i SequenceStep
		if err := rows.Scan(
			&i.ID,
			&i.SequenceID,
			&i.DaysAfterPreviousStep,
			&i.EmailSubject,
			&i.EmailContent,
			&i.Ordering,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSequence = `-- name: UpdateSequence :exec
UPDATE sequences SET open_tracking_enabled = $1, click_tracking_enabled = $2, updated_at = NOW() WHERE id = $3
`

type UpdateSequenceParams struct {
	OpenTrackingEnabled  bool      `db:"open_tracking_enabled"`
	ClickTrackingEnabled bool      `db:"click_tracking_enabled"`
	ID                   uuid.UUID `db:"id"`
}

func (q *Queries) UpdateSequence(ctx context.Context, arg *UpdateSequenceParams) error {
	_, err := q.db.Exec(ctx, updateSequence, arg.OpenTrackingEnabled, arg.ClickTrackingEnabled, arg.ID)
	return err
}

const updateSequenceStep = `-- name: UpdateSequenceStep :exec
UPDATE sequence_steps SET email_subject = $1, email_content = $2, updated_at = NOW() WHERE id = $3
`

type UpdateSequenceStepParams struct {
	EmailSubject string    `db:"email_subject"`
	EmailContent string    `db:"email_content"`
	ID           uuid.UUID `db:"id"`
}

func (q *Queries) UpdateSequenceStep(ctx context.Context, arg *UpdateSequenceStepParams) error {
	_, err := q.db.Exec(ctx, updateSequenceStep, arg.EmailSubject, arg.EmailContent, arg.ID)
	return err
}
